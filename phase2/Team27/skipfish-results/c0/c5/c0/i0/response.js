var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Fri, 13 Nov 2015 15:30:08 GMT\x0aServer: Apache/2.2.22 (Ubuntu)\x0aLast-Modified: Mon, 02 Nov 2015 21:30:59 GMT\x0aETag: \x2210784c-10d1a-523957e43ae27\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-14121/14122\x0aContent-Length: 14122\x0aKeep-Alive: timeout=5, max=6\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*!\x0a * Bootstrap v3.3.5 (http://getbootstrap.com)\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under the MIT license\x0a */\x0a\x0aif (typeof jQuery === \x27undefined\x27) {\x0a  throw new Error(\x27Bootstrap\x5c\x27s JavaScript requires jQuery\x27)\x0a}\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a  var version = $.fn.jquery.split(\x27 \x27)[0].split(\x27.\x27)\x0a  if ((version[0] \x3c 2 && version[1] \x3c 9) || (version[0] == 1 && version[1] == 9 && version[2] \x3c 1)) {\x0a    throw new Error(\x27Bootstrap\x5c\x27s JavaScript requires jQuery version 1.9.1 or higher\x27)\x0a  }\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: transition.js v3.3.5\x0a * http://getbootstrap.com/javascript/#transitions\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\x0a  // ============================================================\x0a\x0a  function transitionEnd() {\x0a    var el = document.createElement(\x27bootstrap\x27)\x0a\x0a    var transEndEventNames = {\x0a      WebkitTransition : \x27webkitTransitionEnd\x27,\x0a      MozTransition    : \x27transitionend\x27,\x0a      OTransition      : \x27oTransitionEnd otransitionend\x27,\x0a      transition       : \x27transitionend\x27\x0a    }\x0a\x0a    for (var name in transEndEventNames) {\x0a      if (el.style[name] !== undefined) {\x0a        return { end: transEndEventNames[name] }\x0a      }\x0a    }\x0a\x0a    return false // explicit for ie8 (  ._.)\x0a  }\x0a\x0a  // http://blog.alexmaccaw.com/css-transitions\x0a  $.fn.emulateTransitionEnd = function (duration) {\x0a    var called = false\x0a    var $el = this\x0a    $(this).one(\x27bsTransitionEnd\x27, function () { called = true })\x0a    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\x0a    setTimeout(callback, duration)\x0a    return this\x0a  }\x0a\x0a  $(function () {\x0a    $.support.transition = transitionEnd()\x0a\x0a    if (!$.support.transition) return\x0a\x0a    $.event.special.bsTransitionEnd = {\x0a      bindType: $.support.transition.end,\x0a      delegateType: $.support.transition.end,\x0a      handle: function (e) {\x0a        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\x0a      }\x0a    }\x0a  })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: alert.js v3.3.5\x0a * http://getbootstrap.com/javascript/#alerts\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // ALERT CLASS DEFINITION\x0a  // ======================\x0a\x0a  var dismiss = \x27[data-dismiss=\x22alert\x22]\x27\x0a  var Alert   = function (el) {\x0a    $(el).on(\x27click\x27, dismiss, this.close)\x0a  }\x0a\x0a  Alert.VERSION = \x273.3.5\x27\x0a\x0a  Alert.TRANSITION_DURATION = 150\x0a\x0a  Alert.prototype.close = function (e) {\x0a    var $this    = $(this)\x0a    var selector = $this.attr(\x27data-target\x27)\x0a\x0a    if (!selector) {\x0a      selector = $this.attr(\x27href\x27)\x0a      selector = selector && selector.replace(/.*(?=#[^\x5cs]*$)/, \x27\x27) // strip for ie7\x0a    }\x0a\x0a    var $parent = $(selector)\x0a\x0a    if (e) e.preventDefault()\x0a\x0a    if (!$parent.length) {\x0a      $parent = $this.closest(\x27.alert\x27)\x0a    }\x0a\x0a    $parent.trigger(e = $.Event(\x27close.bs.alert\x27))\x0a\x0a    if (e.isDefaultPrevented()) return\x0a\x0a    $parent.removeClass(\x27in\x27)\x0a\x0a    function removeElement() {\x0a      // detach from parent, fire event then clean up data\x0a      $parent.detach().trigger(\x27closed.bs.alert\x27).remove()\x0a    }\x0a\x0a    $.support.transition && $parent.hasClass(\x27fade\x27) ?\x0a      $parent\x0a        .one(\x27bsTransitionEnd\x27, removeElement)\x0a        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\x0a      removeElement()\x0a  }\x0a\x0a\x0a  // ALERT PLUGIN DEFINITION\x0a  // =======================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this = $(this)\x0a      var data  = $this.data(\x27bs.alert\x27)\x0a\x0a      if (!data) $this.data(\x27bs.alert\x27, (data = new Alert(this)))\x0a      if (typeof option == \x27string\x27) data[option].call($this)\x0a    })\x0a  }\x0a\x0a  var old = $.fn.alert\x0a\x0a  $.fn.alert             = Plugin\x0a  $.fn.alert.Constructor = Alert\x0a\x0a\x0a  // ALERT NO CONFLICT\x0a  // =================\x0a\x0a  $.fn.alert.noConflict = function () {\x0a    $.fn.alert = old\x0a    return this\x0a  }\x0a\x0a\x0a  // ALERT DATA-API\x0a  // ==============\x0a\x0a  $(document).on(\x27click.bs.alert.data-api\x27, dismiss, Alert.prototype.close)\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: button.js v3.3.5\x0a * http://getbootstrap.com/javascript/#buttons\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // BUTTON PUBLIC CLASS DEFINITION\x0a  // ==============================\x0a\x0a  var Button = function (element, options) {\x0a    this.$element  = $(element)\x0a    this.options   = $.extend({}, Button.DEFAULTS, options)\x0a    this.isLoading = false\x0a  }\x0a\x0a  Button.VERSION  = \x273.3.5\x27\x0a\x0a  Button.DEFAULTS = {\x0a    loadingText: \x27loading...\x27\x0a  }\x0a\x0a  Button.prototype.setState = function (state) {\x0a    var d    = \x27disabled\x27\x0a    var $el  = this.$element\x0a    var val  = $el.is(\x27input\x27) ? \x27val\x27 : \x27html\x27\x0a    var data = $el.data()\x0a\x0a    state += \x27Text\x27\x0a\x0a    if (data.resetText == null) $el.data(\x27resetText\x27, $el[val]())\x0a\x0a    // push to event loop to allow forms to submit\x0a    setTimeout($.proxy(function () {\x0a      $el[val](data[state] == null ? this.options[state] : data[state])\x0a\x0a      if (state == \x27loadingText\x27) {\x0a        this.isLoading = true\x0a        $el.addClass(d).attr(d, d)\x0a      } else if (this.isLoading) {\x0a        this.isLoading = false\x0a        $el.removeClass(d).removeAttr(d)\x0a      }\x0a    }, this), 0)\x0a  }\x0a\x0a  Button.prototype.toggle = function () {\x0a    var changed = true\x0a    var $parent = this.$element.closest(\x27[data-toggle=\x22buttons\x22]\x27)\x0a\x0a    if ($parent.length) {\x0a      var $input = this.$element.find(\x27input\x27)\x0a      if ($input.prop(\x27type\x27) == \x27radio\x27) {\x0a        if ($input.prop(\x27checked\x27)) changed = false\x0a        $parent.find(\x27.active\x27).removeClass(\x27active\x27)\x0a        this.$element.addClass(\x27active\x27)\x0a      } else if ($input.prop(\x27type\x27) == \x27checkbox\x27) {\x0a        if (($input.prop(\x27checked\x27)) !== this.$element.hasClass(\x27active\x27)) changed = false\x0a        this.$element.toggleClass(\x27active\x27)\x0a      }\x0a      $input.prop(\x27checked\x27, this.$element.hasClass(\x27active\x27))\x0a      if (changed) $input.trigger(\x27change\x27)\x0a    } else {\x0a      this.$element.attr(\x27aria-pressed\x27, !this.$element.hasClass(\x27active\x27))\x0a      this.$element.toggleClass(\x27active\x27)\x0a    }\x0a  }\x0a\x0a\x0a  // BUTTON PLUGIN DEFINITION\x0a  // ========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.button\x27)\x0a      var options = typeof option == \x27object\x27 && option\x0a\x0a      if (!data) $this.data(\x27bs.button\x27, (data = new Button(this, options)))\x0a\x0a      if (option == \x27toggle\x27) data.toggle()\x0a      else if (option) data.setState(option)\x0a    })\x0a  }\x0a\x0a  var old = $.fn.button\x0a\x0a  $.fn.button             = Plugin\x0a  $.fn.button.Constructor = Button\x0a\x0a\x0a  // BUTTON NO CONFLICT\x0a  // ==================\x0a\x0a  $.fn.button.noConflict = function () {\x0a    $.fn.button = old\x0a    return this\x0a  }\x0a\x0a\x0a  // BUTTON DATA-API\x0a  // ===============\x0a\x0a  $(document)\x0a    .on(\x27click.bs.button.data-api\x27, \x27[data-toggle^=\x22button\x22]\x27, function (e) {\x0a      var $btn = $(e.target)\x0a      if (!$btn.hasClass(\x27btn\x27)) $btn = $btn.closest(\x27.btn\x27)\x0a      Plugin.call($btn, \x27toggle\x27)\x0a      if (!($(e.target).is(\x27input[type=\x22radio\x22]\x27) || $(e.target).is(\x27input[type=\x22checkbox\x22]\x27))) e.preventDefault()\x0a    })\x0a    .on(\x27focus.bs.button.data-api blur.bs.button.data-api\x27, \x27[data-toggle^=\x22button\x22]\x27, function (e) {\x0a      $(e.target).closest(\x27.btn\x27).toggleClass(\x27focus\x27, /^focus(in)?$/.test(e.type))\x0a    })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: carousel.js v3.3.5\x0a * http://getbootstrap.com/javascript/#carousel\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // CAROUSEL CLASS DEFINITION\x0a  // =========================\x0a\x0a  var Carousel = function (element, options) {\x0a    this.$element    = $(element)\x0a    this.$indicators = this.$element.find(\x27.carousel-indicators\x27)\x0a    this.options     = options\x0a    this.paused      = null\x0a    this.sliding     = null\x0a    this.interval    = null\x0a    this.$active     = null\x0a    this.$items      = null\x0a\x0a    this.options.keyboard && this.$element.on(\x27keydown.bs.carousel\x27, $.proxy(this.keydown, this))\x0a\x0a    this.options.pause == \x27hover\x27 && !(\x27ontouchstart\x27 in document.documentElement) && this.$element\x0a      .on(\x27mouseenter.bs.carousel\x27, $.proxy(this.pause, this))\x0a      .on(\x27mouseleave.bs.carousel\x27, $.proxy(this.cycle, this))\x0a  }\x0a\x0a  Carousel.VERSION  = \x273.3.5\x27\x0a\x0a  Carousel.TRANSITION_DURATION = 600\x0a\x0a  Carousel.DEFAULTS = {\x0a    interval: 5000,\x0a    pause: \x27hover\x27,\x0a    wrap: true,\x0a    keyboard: true\x0a  }\x0a\x0a  Carousel.prototype.keydown = function (e) {\x0a    if (/input|textarea/i.test(e.target.tagName)) return\x0a    switch (e.which) {\x0a      case 37: this.prev(); break\x0a      case 39: this.next(); break\x0a      default: return\x0a    }\x0a\x0a    e.preventDefault()\x0a  }\x0a\x0a  Carousel.prototype.cycle = function (e) {\x0a    e || (this.paused = false)\x0a\x0a    this.interval && clearInterval(this.interval)\x0a\x0a    this.options.interval\x0a      && !this.paused\x0a      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\x0a\x0a    return this\x0a  }\x0a\x0a  Carousel.prototype.getItemIndex = function (item) {\x0a    this.$items = item.parent().children(\x27.item\x27)\x0a    return this.$items.index(item || this.$active)\x0a  }\x0a\x0a  Carousel.prototype.getItemForDirection = function (direction, active) {\x0a    var activeIndex = this.getItemIndex(active)\x0a    var willWrap = (direction == \x27prev\x27 && activeIndex === 0)\x0a                || (direction == \x27next\x27 && activeIndex == (this.$items.length - 1))\x0a    if (willWrap && !this.options.wrap) return active\x0a    var delta = direction == \x27prev\x27 ? -1 : 1\x0a    var itemIndex = (activeIndex + delta) % this.$items.length\x0a    return this.$items.eq(itemIndex)\x0a  }\x0a\x0a  Carousel.prototype.to = function (pos) {\x0a    var that        = this\x0a    var activeIndex = this.getItemIndex(this.$active = this.$element.find(\x27.item.active\x27))\x0a\x0a    if (pos \x3e (this.$items.length - 1) || pos \x3c 0) return\x0a\x0a    if (this.sliding)       return this.$element.one(\x27slid.bs.carousel\x27, function () { that.to(pos) }) // yes, \x22slid\x22\x0a    if (activeIndex == pos) return this.pause().cycle()\x0a\x0a    return this.slide(pos \x3e activeIndex ? \x27next\x27 : \x27prev\x27, this.$items.eq(pos))\x0a  }\x0a\x0a  Carousel.prototype.pause = function (e) {\x0a    e || (this.paused = true)\x0a\x0a    if (this.$element.find(\x27.next, .prev\x27).length && $.support.transition) {\x0a      this.$element.trigger($.support.transition.end)\x0a      this.cycle(true)\x0a    }\x0a\x0a    this.interval = clearInterval(this.interval)\x0a\x0a    return this\x0a  }\x0a\x0a  Carousel.prototype.next = function () {\x0a    if (this.sliding) return\x0a    return this.slide(\x27next\x27)\x0a  }\x0a\x0a  Carousel.prototype.prev = function () {\x0a    if (this.sliding) return\x0a    return this.slide(\x27prev\x27)\x0a  }\x0a\x0a  Carousel.prototype.slide = function (type, next) {\x0a    var $active   = this.$element.find(\x27.item.active\x27)\x0a    var $next     = next || this.getItemForDirection(type, $active)\x0a    var isCycling = this.interval\x0a    var direction = type == \x27next\x27 ? \x27left\x27 : \x27right\x27\x0a    var that      = this\x0a\x0a    if ($next.hasClass(\x27active\x27)) return (this.sliding = false)\x0a\x0a    var relatedTarget = $next[0]\x0a    var slideEvent = $.Event(\x27slide.bs.carousel\x27, {\x0a      relatedTarget: relatedTarget,\x0a      direction: direction\x0a    })\x0a    this.$element.trigger(slideEvent)\x0a    if (slideEvent.isDefaultPrevented()) return\x0a\x0a    this.sliding = true\x0a\x0a    isCycling && this.pause()\x0a\x0a    if (this.$indicators.length) {\x0a      this.$indicators.find(\x27.active\x27).removeClass(\x27active\x27)\x0a      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\x0a      $nextIndicator && $nextIndicator.addClass(\x27active\x27)\x0a    }\x0a\x0a    var slidEvent = $.Event(\x27slid.bs.carousel\x27, { relatedTarget: relatedTarget, direction: direction }) // yes, \x22slid\x22\x0a    if ($.support.transition && this.$element.hasClass(\x27slide\x27)) {\x0a      $next.addClass(type)\x0a      $next[0].offsetWidth // force reflow\x0a      $active.addClass(direction)\x0a      $next.addClass(direction)\x0a      $active\x0a        .one(\x27bsTransitionEnd\x27, function () {\x0a          $next.removeClass([type, direction].join(\x27 \x27)).addClass(\x27active\x27)\x0a          $active.removeClass([\x27active\x27, direction].join(\x27 \x27))\x0a          that.sliding = false\x0a          setTimeout(function () {\x0a            that.$element.trigger(slidEvent)\x0a          }, 0)\x0a        })\x0a        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\x0a    } else {\x0a      $active.removeClass(\x27active\x27)\x0a      $next.addClass(\x27active\x27)\x0a      this.sliding = false\x0a      this.$element.trigger(slidEvent)\x0a    }\x0a\x0a    isCycling && this.cycle()\x0a\x0a    return this\x0a  }\x0a\x0a\x0a  // CAROUSEL PLUGIN DEFINITION\x0a  // ==========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.carousel\x27)\x0a      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == \x27object\x27 && option)\x0a      var action  = typeof option == \x27string\x27 ? option : options.slide\x0a\x0a      if (!data) $this.data(\x27bs.carousel\x27, (data = new Carousel(this, options)))\x0a      if (typeof option == \x27number\x27) data.to(option)\x0a      else if (action) data[action]()\x0a      else if (options.interval) data.pause().cycle()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.carousel\x0a\x0a  $.fn.carousel             = Plugin\x0a  $.fn.carousel.Constructor = Carousel\x0a\x0a\x0a  // CAROUSEL NO CONFLICT\x0a  // ====================\x0a\x0a  $.fn.carousel.noConflict = function () {\x0a    $.fn.carousel = old\x0a    return this\x0a  }\x0a\x0a\x0a  // CAROUSEL DATA-API\x0a  // =================\x0a\x0a  var clickHandler = function (e) {\x0a    var href\x0a    var $this   = $(this)\x0a    var $target = $($this.attr(\x27data-target\x27) || (href = $this.attr(\x27href\x27)) && href.replace(/.*(?=#[^\x5cs]+$)/, \x27\x27)) // strip for ie7\x0a    if (!$target.hasClass(\x27carousel\x27)) return\x0a    var options = $.extend({}, $target.data(), $this.data())\x0a    var slideIndex = $this.attr(\x27data-slide-to\x27)\x0a    if (slideIndex) options.interval = false\x0a\x0a    Plugin.call($target, options)\x0a\x0a    if (slideIndex) {\x0a      $target.data(\x27bs.carousel\x27).to(slideIndex)\x0a    }\x0a\x0a    e.preventDefault()\x0a  }\x0a\x0a  $(document)\x0a    .on(\x27click.bs.carousel.data-api\x27, \x27[data-slide]\x27, clickHandler)\x0a    .on(\x27click.bs.carousel.data-api\x27, \x27[data-slide-to]\x27, clickHandler)\x0a\x0a  $(window).on(\x27load\x27, function () {\x0a    $(\x27[data-ride=\x22carousel\x22]\x27).each(function () {\x0a      var $carousel = $(this)\x0a      Plugin.call($carousel, $carousel.data())\x0a    })\x0a  })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: collapse.js v3.3.5\x0a * http://getbootstrap.com/javascript/#collapse\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // COLLAPSE PUBLIC CLASS DEFINITION\x0a  // ================================\x0a\x0a  var Collapse = function (element, options) {\x0a    this.$element      = $(element)\x0a    this.options       = $.extend({}, Collapse.DEFAULTS, options)\x0a    this.$trigger      = $(\x27[data-toggle=\x22collapse\x22][href=\x22#\x27 + element.id + \x27\x22],\x27 +\x0a                           \x27[data-toggle=\x22collapse\x22][data-target=\x22#\x27 + element.id + \x27\x22]\x27)\x0a    this.transitioning = null\x0a\x0a    if (this.options.parent) {\x0a      this.$parent = this.getParent()\x0a    } else {\x0a      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\x0a    }\x0a\x0a    if (this.options.toggle) this.toggle()\x0a  }\x0a\x0a  Collapse.VERSION  = \x273.3.5\x27\x0a\x0a  Collapse.TRANSITION_DURATION = 350\x0a\x0a  Collapse.DEFAULTS = {\x0a    toggle: true\x0a  }\x0a\x0a  Collapse.prototype.dimension = function () {\x0a    var hasWidth = this.$element.hasClass(\x27width\x27)\x0a    return hasWidth ? \x27width\x27 : \x27height\x27\x0a  }\x0a\x0a  Collapse.prototype.show = function () {\x0a    if (this.transitioning || this.$element.hasClass(\x27in\x27)) return\x0a\x0a    var activesData\x0a    var actives = this.$parent && this.$parent.children(\x27.panel\x27).children(\x27.in, .collapsing\x27)\x0a\x0a    if (actives && actives.length) {\x0a      activesData = actives.data(\x27bs.collapse\x27)\x0a      if (activesData && activesData.transitioning) return\x0a    }\x0a\x0a    var startEvent = $.Event(\x27show.bs.collapse\x27)\x0a    this.$element.trigger(startEvent)\x0a    if (startEvent.isDefaultPrevented()) return\x0a\x0a    if (actives && actives.length) {\x0a      Plugin.call(actives, \x27hide\x27)\x0a      activesData || actives.data(\x27bs.collapse\x27, null)\x0a    }\x0a\x0a    var dimension = this.dimension()\x0a\x0a    this.$element\x0a      .removeClass(\x27collapse\x27)\x0a      .addClass(\x27collapsing\x27)[dimension](0)\x0a      .attr(\x27aria-expanded\x27, true)\x0a\x0a    this.$trigger\x0a      .removeClass(\x27collapsed\x27)\x0a      .attr(\x27aria-expanded\x27, true)\x0a\x0a    this.transitioning = 1\x0a\x0a    var complete = function () {\x0a      this.$element\x0a        .removeClass(\x27collapsing\x27)\x0a        .addClass(\x27collapse in\x27)[dimension](\x27\x27)\x0a      this.transitioning = 0\x0a      this.$element\x0a        .trigger(\x27shown.bs.collapse\x27)\x0a    }\x0a\x0a    if (!$.support.transition) return complete.call(this)\x0a\x0a    var scrollSize = $.camelCase([\x27scroll\x27, dimension].join(\x27-\x27))\x0a\x0a    this.$element\x0a      .one(\x27bsTransitionEnd\x27, $.proxy(complete, this))\x0a      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\x0a  }\x0a\x0a  Collapse.prototype.hide = function () {\x0a    if (this.transitioning || !this.$element.hasClass(\x27in\x27)) return\x0a\x0a    var startEvent = $.Event(\x27hide.bs.collapse\x27)\x0a    this.$element.trigger(startEvent)\x0a    if (startEvent.isDefaultPrevented()) return\x0a\x0a    var dimension = this.dimension()\x0a\x0a    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\x0a\x0a    this.$element\x0a      .addClass(\x27collapsing\x27)\x0a      .removeClass(\x27collapse in\x27)\x0a      .attr(\x27aria-expanded\x27, false)\x0a\x0a    this.$trigger\x0a      .addClass(\x27collapsed\x27)\x0a      .attr(\x27aria-expanded\x27, false)\x0a\x0a    this.transitioning = 1\x0a\x0a    var complete = function () {\x0a      this.transitioning = 0\x0a      this.$element\x0a        .removeClass(\x27collapsing\x27)\x0a        .addClass(\x27collapse\x27)\x0a        .trigger(\x27hidden.bs.collapse\x27)\x0a    }\x0a\x0a    if (!$.support.transition) return complete.call(this)\x0a\x0a    this.$element\x0a      [dimension](0)\x0a      .one(\x27bsTransitionEnd\x27, $.proxy(complete, this))\x0a      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\x0a  }\x0a\x0a  Collapse.prototype.toggle = function () {\x0a    this[this.$element.hasClass(\x27in\x27) ? \x27hide\x27 : \x27show\x27]()\x0a  }\x0a\x0a  Collapse.prototype.getParent = function () {\x0a    return $(this.options.parent)\x0a      .find(\x27[data-toggle=\x22collapse\x22][data-parent=\x22\x27 + this.options.parent + \x27\x22]\x27)\x0a      .each($.proxy(function (i, element) {\x0a        var $element = $(element)\x0a        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\x0a      }, this))\x0a      .end()\x0a  }\x0a\x0a  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\x0a    var isOpen = $element.hasClass(\x27in\x27)\x0a\x0a    $element.attr(\x27aria-expanded\x27, isOpen)\x0a    $trigger\x0a      .toggleClass(\x27collapsed\x27, !isOpen)\x0a      .attr(\x27aria-expanded\x27, isOpen)\x0a  }\x0a\x0a  function getTargetFromTrigger($trigger) {\x0a    var href\x0a    var target = $trigger.attr(\x27data-target\x27)\x0a      || (href = $trigger.attr(\x27href\x27)) && href.replace(/.*(?=#[^\x5cs]+$)/, \x27\x27) // strip for ie7\x0a\x0a    return $(target)\x0a  }\x0a\x0a\x0a  // COLLAPSE PLUGIN DEFINITION\x0a  // ==========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.collapse\x27)\x0a      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == \x27object\x27 && option)\x0a\x0a      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\x0a      if (!data) $this.data(\x27bs.collapse\x27, (data = new Collapse(this, options)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.collapse\x0a\x0a  $.fn.collapse             = Plugin\x0a  $.fn.collapse.Constructor = Collapse\x0a\x0a\x0a  // COLLAPSE NO CONFLICT\x0a  // ====================\x0a\x0a  $.fn.collapse.noConflict = function () {\x0a    $.fn.collapse = old\x0a    return this\x0a  }\x0a\x0a\x0a  // COLLAPSE DATA-API\x0a  // =================\x0a\x0a  $(document).on(\x27click.bs.collapse.data-api\x27, \x27[data-toggle=\x22collapse\x22]\x27, function (e) {\x0a    var $this   = $(this)\x0a\x0a    if (!$this.attr(\x27data-target\x27)) e.preventDefault()\x0a\x0a    var $target = getTargetFromTrigger($this)\x0a    var data    = $target.data(\x27bs.collapse\x27)\x0a    var option  = data ? \x27toggle\x27 : $this.data()\x0a\x0a    Plugin.call($target, option)\x0a  })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: dropdown.js v3.3.5\x0a * http://getbootstrap.com/javascript/#dropdowns\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // DROPDOWN CLASS DEFINITION\x0a  // =========================\x0a\x0a  var backdrop = \x27.dropdown-backdrop\x27\x0a  var toggle   = \x27[data-toggle=\x22dropdown\x22]\x27\x0a  var Dropdown = function (element) {\x0a    $(element).on(\x27click.bs.dropdown\x27, this.toggle)\x0a  }\x0a\x0a  Dropdown.VERSION = \x273.3.5\x27\x0a\x0a  function getParent($this) {\x0a    var selector = $this.attr(\x27data-target\x27)\x0a\x0a    if (!selector) {\x0a      selector = $this.attr(\x27href\x27)\x0a      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\x5cs]*$)/, \x27\x27) // strip for ie7\x0a    }\x0a\x0a    var $parent = selector && $(selector)\x0a\x0a    return $parent && $parent.length ? $parent : $this.parent()\x0a  }\x0a\x0a  function clearMenus(e) {\x0a    if (e && e.which === 3) return\x0a    $(backdrop).remove()\x0a    $(toggle).each(function () {\x0a      var $this         = $(this)\x0a      var $parent       = getParent($this)\x0a      var relatedTarget = { relatedTarget: this }\x0a\x0a      if (!$parent.hasClass(\x27open\x27)) return\x0a\x0a      if (e && e.type == \x27click\x27 && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\x0a\x0a      $parent.trigger(e = $.Event(\x27hide.bs.dropdown\x27, relatedTarget))\x0a\x0a      if (e.isDefaultPrevented()) return\x0a\x0a      $this.attr(\x27aria-expanded\x27, \x27false\x27)\x0a      $parent.removeClass(\x27open\x27).trigger(\x27hidden.bs.dropdown\x27, relatedTarget)\x0a    })\x0a  }\x0a\x0a  Dropdown.prototype.toggle = function (e) {\x0a    var $this = $(this)\x0a\x0a    if ($this.is(\x27.disabled, :disabled\x27)) return\x0a\x0a    var $parent  = getParent($this)\x0a    var isActive = $parent.hasClass(\x27open\x27)\x0a\x0a    clearMenus()\x0a\x0a    if (!isActive) {\x0a      if (\x27ontouchstart\x27 in document.documentElement && !$parent.closest(\x27.navbar-nav\x27).length) {\x0a        // if mobile we use a backdrop because click events don\x27t delegate\x0a        $(document.createElement(\x27div\x27))\x0a          .addClass(\x27dropdown-backdrop\x27)\x0a          .insertAfter($(this))\x0a          .on(\x27click\x27, clearMenus)\x0a      }\x0a\x0a      var relatedTarget = { relatedTarget: this }\x0a      $parent.trigger(e = $.Event(\x27show.bs.dropdown\x27, relatedTarget))\x0a\x0a      if (e.isDefaultPrevented()) return\x0a\x0a      $this\x0a        .trigger(\x27focus\x27)\x0a        .attr(\x27aria-expanded\x27, \x27true\x27)\x0a\x0a      $parent\x0a        .toggleClass(\x27open\x27)\x0a        .trigger(\x27shown.bs.dropdown\x27, relatedTarget)\x0a    }\x0a\x0a    return false\x0a  }\x0a\x0a  Dropdown.prototype.keydown = function (e) {\x0a    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\x0a\x0a    var $this = $(this)\x0a\x0a    e.preventDefault()\x0a    e.stopPropagation()\x0a\x0a    if ($this.is(\x27.disabled, :disabled\x27)) return\x0a\x0a    var $parent  = getParent($this)\x0a    var isActive = $parent.hasClass(\x27open\x27)\x0a\x0a    if (!isActive && e.which != 27 || isActive && e.which == 27) {\x0a      if (e.which == 27) $parent.find(toggle).trigger(\x27focus\x27)\x0a      return $this.trigger(\x27click\x27)\x0a    }\x0a\x0a    var desc = \x27 li:not(.disabled):visible a\x27\x0a    var $items = $parent.find(\x27.dropdown-menu\x27 + desc)\x0a\x0a    if (!$items.length) return\x0a\x0a    var index = $items.index(e.target)\x0a\x0a    if (e.which == 38 && index \x3e 0)                 index--         // up\x0a    if (e.which == 40 && index \x3c $items.length - 1) index++         // down\x0a    if (!~index)                                    index = 0\x0a\x0a    $items.eq(index).trigger(\x27focus\x27)\x0a  }\x0a\x0a\x0a  // DROPDOWN PLUGIN DEFINITION\x0a  // ==========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this = $(this)\x0a      var data  = $this.data(\x27bs.dropdown\x27)\x0a\x0a      if (!data) $this.data(\x27bs.dropdown\x27, (data = new Dropdown(this)))\x0a      if (typeof option == \x27string\x27) data[option].call($this)\x0a    })\x0a  }\x0a\x0a  var old = $.fn.dropdown\x0a\x0a  $.fn.dropdown             = Plugin\x0a  $.fn.dropdown.Constructor = Dropdown\x0a\x0a\x0a  // DROPDOWN NO CONFLICT\x0a  // ====================\x0a\x0a  $.fn.dropdown.noConflict = function () {\x0a    $.fn.dropdown = old\x0a    return this\x0a  }\x0a\x0a\x0a  // APPLY TO STANDARD DROPDOWN ELEMENTS\x0a  // ===================================\x0a\x0a  $(document)\x0a    .on(\x27click.bs.dropdown.data-api\x27, clearMenus)\x0a    .on(\x27click.bs.dropdown.data-api\x27, \x27.dropdown form\x27, function (e) { e.stopPropagation() })\x0a    .on(\x27click.bs.dropdown.data-api\x27, toggle, Dropdown.prototype.toggle)\x0a    .on(\x27keydown.bs.dropdown.data-api\x27, toggle, Dropdown.prototype.keydown)\x0a    .on(\x27keydown.bs.dropdown.data-api\x27, \x27.dropdown-menu\x27, Dropdown.prototype.keydown)\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: modal.js v3.3.5\x0a * http://getbootstrap.com/javascript/#modals\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // MODAL CLASS DEFINITION\x0a  // ======================\x0a\x0a  var Modal = function (element, options) {\x0a    this.options             = options\x0a    this.$body               = $(document.body)\x0a    this.$element            = $(element)\x0a    this.$dialog             = this.$element.find(\x27.modal-dialog\x27)\x0a    this.$backdrop           = null\x0a    this.isShown             = null\x0a    this.originalBodyPad     = null\x0a    this.scrollbarWidth      = 0\x0a    this.ignoreBackdropClick = false\x0a\x0a    if (this.options.remote) {\x0a      this.$element\x0a        .find(\x27.modal-content\x27)\x0a        .load(this.options.remote, $.proxy(function () {\x0a          this.$element.trigger(\x27loaded.bs.modal\x27)\x0a        }, this))\x0a    }\x0a  }\x0a\x0a  Modal.VERSION  = \x273.3.5\x27\x0a\x0a  Modal.TRANSITION_DURATION = 300\x0a  Modal.BACKDROP_TRANSITION_DURATION = 150\x0a\x0a  Modal.DEFAULTS = {\x0a    backdrop: true,\x0a    keyboard: true,\x0a    show: true\x0a  }\x0a\x0a  Modal.prototype.toggle = function (_relatedTarget) {\x0a    return this.isShown ? this.hide() : this.show(_relatedTarget)\x0a  }\x0a\x0a  Modal.prototype.show = function (_relatedTarget) {\x0a    var that = this\x0a    var e    = $.Event(\x27show.bs.modal\x27, { relatedTarget: _relatedTarget })\x0a\x0a    this.$element.trigger(e)\x0a\x0a    if (this.isShown || e.isDefaultPrevented()) return\x0a\x0a    this.isShown = true\x0a\x0a    this.checkScrollbar()\x0a    this.setScrollbar()\x0a    this.$body.addClass(\x27modal-open\x27)\x0a\x0a    this.escape()\x0a    this.resize()\x0a\x0a    this.$element.on(\x27click.dismiss.bs.modal\x27, \x27[data-dismiss=\x22modal\x22]\x27, $.proxy(this.hide, this))\x0a\x0a    this.$dialog.on(\x27mousedown.dismiss.bs.modal\x27, function () {\x0a      that.$element.one(\x27mouseup.dismiss.bs.modal\x27, function (e) {\x0a        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\x0a      })\x0a    })\x0a\x0a    this.backdrop(function () {\x0a      var transition = $.support.transition && that.$element.hasClass(\x27fade\x27)\x0a\x0a      if (!that.$element.parent().length) {\x0a        that.$element.appendTo(that.$body) // don\x27t move modals dom position\x0a      }\x0a\x0a      that.$element\x0a        .show()\x0a        .scrollTop(0)\x0a\x0a      that.adjustDialog()\x0a\x0a      if (transition) {\x0a        that.$element[0].offsetWidth // force reflow\x0a      }\x0a\x0a      that.$element.addClass(\x27in\x27)\x0a\x0a      that.enforceFocus()\x0a\x0a      var e = $.Event(\x27shown.bs.modal\x27, { relatedTarget: _relatedTarget })\x0a\x0a      transition ?\x0a        that.$dialog // wait for modal to slide in\x0a          .one(\x27bsTransitionEnd\x27, function () {\x0a            that.$element.trigger(\x27focus\x27).trigger(e)\x0a          })\x0a          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\x0a        that.$element.trigger(\x27focus\x27).trigger(e)\x0a    })\x0a  }\x0a\x0a  Modal.prototype.hide = function (e) {\x0a    if (e) e.preventDefault()\x0a\x0a    e = $.Event(\x27hide.bs.modal\x27)\x0a\x0a    this.$element.trigger(e)\x0a\x0a    if (!this.isShown || e.isDefaultPrevented()) return\x0a\x0a    this.isShown = false\x0a\x0a    this.escape()\x0a    this.resize()\x0a\x0a    $(document).off(\x27focusin.bs.modal\x27)\x0a\x0a    this.$element\x0a      .removeClass(\x27in\x27)\x0a      .off(\x27click.dismiss.bs.modal\x27)\x0a      .off(\x27mouseup.dismiss.bs.modal\x27)\x0a\x0a    this.$dialog.off(\x27mousedown.dismiss.bs.modal\x27)\x0a\x0a    $.support.transition && this.$element.hasClass(\x27fade\x27) ?\x0a      this.$element\x0a        .one(\x27bsTransitionEnd\x27, $.proxy(this.hideModal, this))\x0a        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\x0a      this.hideModal()\x0a  }\x0a\x0a  Modal.prototype.enforceFocus = function () {\x0a    $(document)\x0a      .off(\x27focusin.bs.modal\x27) // guard against infinite focus loop\x0a      .on(\x27focusin.bs.modal\x27, $.proxy(function (e) {\x0a        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\x0a          this.$element.trigger(\x27focus\x27)\x0a        }\x0a      }, this))\x0a  }\x0a\x0a  Modal.prototype.escape = function () {\x0a    if (this.isShown && this.options.keyboard) {\x0a      this.$element.on(\x27keydown.dismiss.bs.modal\x27, $.proxy(function (e) {\x0a        e.which == 27 && this.hide()\x0a      }, this))\x0a    } else if (!this.isShown) {\x0a      this.$element.off(\x27keydown.dismiss.bs.modal\x27)\x0a    }\x0a  }\x0a\x0a  Modal.prototype.resize = function () {\x0a    if (this.isShown) {\x0a      $(window).on(\x27resize.bs.modal\x27, $.proxy(this.handleUpdate, this))\x0a    } else {\x0a      $(window).off(\x27resize.bs.modal\x27)\x0a    }\x0a  }\x0a\x0a  Modal.prototype.hideModal = function () {\x0a    var that = this\x0a    this.$element.hide()\x0a    this.backdrop(function () {\x0a      that.$body.removeClass(\x27modal-open\x27)\x0a      that.resetAdjustments()\x0a      that.resetScrollbar()\x0a      that.$element.trigger(\x27hidden.bs.modal\x27)\x0a    })\x0a  }\x0a\x0a  Modal.prototype.removeBackdrop = function () {\x0a    this.$backdrop && this.$backdrop.remove()\x0a    this.$backdrop = null\x0a  }\x0a\x0a  Modal.prototype.backdrop = function (callback) {\x0a    var that = this\x0a    var animate = this.$element.hasClass(\x27fade\x27) ? \x27fade\x27 : \x27\x27\x0a\x0a    if (this.isShown && this.options.backdrop) {\x0a      var doAnimate = $.support.transition && animate\x0a\x0a      this.$backdrop = $(document.createElement(\x27div\x27))\x0a        .addClass(\x27modal-backdrop \x27 + animate)\x0a        .appendTo(this.$body)\x0a\x0a      this.$element.on(\x27click.dismiss.bs.modal\x27, $.proxy(function (e) {\x0a        if (this.ignoreBackdropClick) {\x0a          this.ignoreBackdropClick = false\x0a          return\x0a        }\x0a        if (e.target !== e.currentTarget) return\x0a        this.options.backdrop == \x27static\x27\x0a          ? this.$element[0].focus()\x0a          : this.hide()\x0a      }, this))\x0a\x0a      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\x0a\x0a      this.$backdrop.addClass(\x27in\x27)\x0a\x0a      if (!callback) return\x0a\x0a      doAnimate ?\x0a        this.$backdrop\x0a          .one(\x27bsTransitionEnd\x27, callback)\x0a          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\x0a        callback()\x0a\x0a    } else if (!this.isShown && this.$backdrop) {\x0a      this.$backdrop.removeClass(\x27in\x27)\x0a\x0a      var callbackRemove = function () {\x0a        that.removeBackdrop()\x0a        callback && callback()\x0a      }\x0a      $.support.transition && this.$element.hasClass(\x27fade\x27) ?\x0a        this.$backdrop\x0a          .one(\x27bsTransitionEnd\x27, callbackRemove)\x0a          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\x0a        callbackRemove()\x0a\x0a    } else if (callback) {\x0a      callback()\x0a    }\x0a  }\x0a\x0a  // these following methods are used to handle overflowing modals\x0a\x0a  Modal.prototype.handleUpdate = function () {\x0a    this.adjustDialog()\x0a  }\x0a\x0a  Modal.prototype.adjustDialog = function () {\x0a    var modalIsOverflowing = this.$element[0].scrollHeight \x3e document.documentElement.clientHeight\x0a\x0a    this.$element.css({\x0a      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : \x27\x27,\x0a      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : \x27\x27\x0a    })\x0a  }\x0a\x0a  Modal.prototype.resetAdjustments = function () {\x0a    this.$element.css({\x0a      paddingLeft: \x27\x27,\x0a      paddingRight: \x27\x27\x0a    })\x0a  }\x0a\x0a  Modal.prototype.checkScrollbar = function () {\x0a    var fullWindowWidth = window.innerWidth\x0a    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\x0a      var documentElementRect = document.documentElement.getBoundingClientRect()\x0a      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\x0a    }\x0a    this.bodyIsOverflowing = document.body.clientWidth \x3c fullWindowWidth\x0a    this.scrollbarWidth = this.measureScrollbar()\x0a  }\x0a\x0a  Modal.prototype.setScrollbar = function () {\x0a    var bodyPad = parseInt((this.$body.css(\x27padding-right\x27) || 0), 10)\x0a    this.originalBodyPad = document.body.style.paddingRight || \x27\x27\x0a    if (this.bodyIsOverflowing) this.$body.css(\x27padding-right\x27, bodyPad + this.scrollbarWidth)\x0a  }\x0a\x0a  Modal.prototype.resetScrollbar = function () {\x0a    this.$body.css(\x27padding-right\x27, this.originalBodyPad)\x0a  }\x0a\x0a  Modal.prototype.measureScrollbar = function () { // thx walsh\x0a    var scrollDiv = document.createElement(\x27div\x27)\x0a    scrollDiv.className = \x27modal-scrollbar-measure\x27\x0a    this.$body.append(scrollDiv)\x0a    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\x0a    this.$body[0].removeChild(scrollDiv)\x0a    return scrollbarWidth\x0a  }\x0a\x0a\x0a  // MODAL PLUGIN DEFINITION\x0a  // =======================\x0a\x0a  function Plugin(option, _relatedTarget) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.modal\x27)\x0a      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == \x27object\x27 && option)\x0a\x0a      if (!data) $this.data(\x27bs.modal\x27, (data = new Modal(this, options)))\x0a      if (typeof option == \x27string\x27) data[option](_relatedTarget)\x0a      else if (options.show) data.show(_relatedTarget)\x0a    })\x0a  }\x0a\x0a  var old = $.fn.modal\x0a\x0a  $.fn.modal             = Plugin\x0a  $.fn.modal.Constructor = Modal\x0a\x0a\x0a  // MODAL NO CONFLICT\x0a  // =================\x0a\x0a  $.fn.modal.noConflict = function () {\x0a    $.fn.modal = old\x0a    return this\x0a  }\x0a\x0a\x0a  // MODAL DATA-API\x0a  // ==============\x0a\x0a  $(document).on(\x27click.bs.modal.data-api\x27, \x27[data-toggle=\x22modal\x22]\x27, function (e) {\x0a    var $this   = $(this)\x0a    var href    = $this.attr(\x27href\x27)\x0a    var $target = $($this.attr(\x27data-target\x27) || (href && href.replace(/.*(?=#[^\x5cs]+$)/, \x27\x27))) // strip for ie7\x0a    var option  = $target.data(\x27bs.modal\x27) ? \x27toggle\x27 : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\x0a\x0a    if ($this.is(\x27a\x27)) e.preventDefault()\x0a\x0a    $target.one(\x27show.bs.modal\x27, function (showEvent) {\x0a      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\x0a      $target.one(\x27hidden.bs.modal\x27, function () {\x0a        $this.is(\x27:visible\x27) && $this.trigger(\x27focus\x27)\x0a      })\x0a    })\x0a    Plugin.call($target, option, this)\x0a  })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: tooltip.js v3.3.5\x0a * http://getbootstrap.com/javascript/#tooltip\x0a * Inspired by the original jQuery.tipsy by Jason Frame\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // TOOLTIP PUBLIC CLASS DEFINITION\x0a  // ===============================\x0a\x0a  var Tooltip = function (element, options) {\x0a    this.type       = null\x0a    this.options    = null\x0a    this.enabled    = null\x0a    this.timeout    = null\x0a    this.hoverState = null\x0a    this.$element   = null\x0a    this.inState    = null\x0a\x0a    this.init(\x27tooltip\x27, element, options)\x0a  }\x0a\x0a  Tooltip.VERSION  = \x273.3.5\x27\x0a\x0a  Tooltip.TRANSITION_DURATION = 150\x0a\x0a  Tooltip.DEFAULTS = {\x0a    animation: true,\x0a    placement: \x27top\x27,\x0a    selector: false,\x0a    template: \x27\x3cdiv class=\x22tooltip\x22 role=\x22tooltip\x22\x3e\x3cdiv class=\x22tooltip-arrow\x22\x3e\x3c/div\x3e\x3cdiv class=\x22tooltip-inner\x22\x3e\x3c/div\x3e\x3c/div\x3e\x27,\x0a    trigger: \x27hover focus\x27,\x0a    title: \x27\x27,\x0a    delay: 0,\x0a    html: false,\x0a    container: false,\x0a    viewport: {\x0a      selector: \x27body\x27,\x0a      padding: 0\x0a    }\x0a  }\x0a\x0a  Tooltip.prototype.init = function (type, element, options) {\x0a    this.enabled   = true\x0a    this.type      = type\x0a    this.$element  = $(element)\x0a    this.options   = this.getOptions(options)\x0a    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\x0a    this.inState   = { click: false, hover: false, focus: false }\x0a\x0a    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\x0a      throw new Error(\x27`selector` option must be specified when initializing \x27 + this.type + \x27 on the window.document object!\x27)\x0a    }\x0a\x0a    var triggers = this.options.trigger.split(\x27 \x27)\x0a\x0a    for (var i = triggers.length; i--;) {\x0a      var trigger = triggers[i]\x0a\x0a      if (trigger == \x27click\x27) {\x0a        this.$element.on(\x27click.\x27 + this.type, this.options.selector, $.proxy(this.toggle, this))\x0a      } else if (trigger != \x27manual\x27) {\x0a        var eventIn  = trigger == \x27hover\x27 ? \x27mouseenter\x27 : \x27focusin\x27\x0a        var eventOut = trigger == \x27hover\x27 ? \x27mouseleave\x27 : \x27focusout\x27\x0a\x0a        this.$element.on(eventIn  + \x27.\x27 + this.type, this.options.selector, $.proxy(this.enter, this))\x0a        this.$element.on(eventOut + \x27.\x27 + this.type, this.options.selector, $.proxy(this.leave, this))\x0a      }\x0a    }\x0a\x0a    this.options.selector ?\x0a      (this._options = $.extend({}, this.options, { trigger: \x27manual\x27, selector: \x27\x27 })) :\x0a      this.fixTitle()\x0a  }\x0a\x0a  Tooltip.prototype.getDefaults = function () {\x0a    return Tooltip.DEFAULTS\x0a  }\x0a\x0a  Tooltip.prototype.getOptions = function (options) {\x0a    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\x0a\x0a    if (options.delay && typeof options.delay == \x27number\x27) {\x0a      options.delay = {\x0a        show: options.delay,\x0a        hide: options.delay\x0a      }\x0a    }\x0a\x0a    return options\x0a  }\x0a\x0a  Tooltip.prototype.getDelegateOptions = function () {\x0a    var options  = {}\x0a    var defaults = this.getDefaults()\x0a\x0a    this._options && $.each(this._options, function (key, value) {\x0a      if (defaults[key] != value) options[key] = value\x0a    })\x0a\x0a    return options\x0a  }\x0a\x0a  Tooltip.prototype.enter = function (obj) {\x0a    var self = obj instanceof this.constructor ?\x0a      obj : $(obj.currentTarget).data(\x27bs.\x27 + this.type)\x0a\x0a    if (!self) {\x0a      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\x0a      $(obj.currentTarget).data(\x27bs.\x27 + this.type, self)\x0a    }\x0a\x0a    if (obj instanceof $.Event) {\x0a      self.inState[obj.type == \x27focusin\x27 ? \x27focus\x27 : \x27hover\x27] = true\x0a    }\x0a\x0a    if (self.tip().hasClass(\x27in\x27) || self.hoverState == \x27in\x27) {\x0a      self.hoverState = \x27in\x27\x0a      return\x0a    }\x0a\x0a    clearTimeout(self.timeout)\x0a\x0a    self.hoverState = \x27in\x27\x0a\x0a    if (!self.options.delay || !self.options.delay.show) return self.show()\x0a\x0a    self.timeout = setTimeout(function () {\x0a      if (self.hoverState == \x27in\x27) self.show()\x0a    }, self.options.delay.show)\x0a  }\x0a\x0a  Tooltip.prototype.isInStateTrue = function () {\x0a    for (var key in this.inState) {\x0a      if (this.inState[key]) return true\x0a    }\x0a\x0a    return false\x0a  }\x0a\x0a  Tooltip.prototype.leave = function (obj) {\x0a    var self = obj instanceof this.constructor ?\x0a      obj : $(obj.currentTarget).data(\x27bs.\x27 + this.type)\x0a\x0a    if (!self) {\x0a      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\x0a      $(obj.currentTarget).data(\x27bs.\x27 + this.type, self)\x0a    }\x0a\x0a    if (obj instanceof $.Event) {\x0a      self.inState[obj.type == \x27focusout\x27 ? \x27focus\x27 : \x27hover\x27] = false\x0a    }\x0a\x0a    if (self.isInStateTrue()) return\x0a\x0a    clearTimeout(self.timeout)\x0a\x0a    self.hoverState = \x27out\x27\x0a\x0a    if (!self.options.delay || !self.options.delay.hide) return self.hide()\x0a\x0a    self.timeout = setTimeout(function () {\x0a      if (self.hoverState == \x27out\x27) self.hide()\x0a    }, self.options.delay.hide)\x0a  }\x0a\x0a  Tooltip.prototype.show = function () {\x0a    var e = $.Event(\x27show.bs.\x27 + this.type)\x0a\x0a    if (this.hasContent() && this.enabled) {\x0a      this.$element.trigger(e)\x0a\x0a      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\x0a      if (e.isDefaultPrevented() || !inDom) return\x0a      var that = this\x0a\x0a      var $tip = this.tip()\x0a\x0a      var tipId = this.getUID(this.type)\x0a\x0a      this.setContent()\x0a      $tip.attr(\x27id\x27, tipId)\x0a      this.$element.attr(\x27aria-describedby\x27, tipId)\x0a\x0a      if (this.options.animation) $tip.addClass(\x27fade\x27)\x0a\x0a      var placement = typeof this.options.placement == \x27function\x27 ?\x0a        this.options.placement.call(this, $tip[0], this.$element[0]) :\x0a        this.options.placement\x0a\x0a      var autoToken = /\x5cs?auto?\x5cs?/i\x0a      var autoPlace = autoToken.test(placement)\x0a      if (autoPlace) placement = placement.replace(autoToken, \x27\x27) || \x27top\x27\x0a\x0a      $tip\x0a        .detach()\x0a        .css({ top: 0, left: 0, display: \x27block\x27 })\x0a        .addClass(placement)\x0a        .data(\x27bs.\x27 + this.type, this)\x0a\x0a      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\x0a      this.$element.trigger(\x27inserted.bs.\x27 + this.type)\x0a\x0a      var pos          = this.getPosition()\x0a      var actualWidth  = $tip[0].offsetWidth\x0a      var actualHeight = $tip[0].offsetHeight\x0a\x0a      if (autoPlace) {\x0a        var orgPlacement = placement\x0a        var viewportDim = this.getPosition(this.$viewport)\x0a\x0a        placement = placement == \x27bottom\x27 && pos.bottom + actualHeight \x3e viewportDim.bottom ? \x27top\x27    :\x0a                    placement == \x27top\x27    && pos.top    - actualHeight \x3c viewportDim.top    ? \x27bottom\x27 :\x0a                    placement == \x27right\x27  && pos.right  + actualWidth  \x3e viewportDim.width  ? \x27left\x27   :\x0a                    placement == \x27left\x27   && pos.left   - actualWidth  \x3c viewportDim.left   ? \x27right\x27  :\x0a                    placement\x0a\x0a        $tip\x0a          .removeClass(orgPlacement)\x0a          .addClass(placement)\x0a      }\x0a\x0a      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\x0a\x0a      this.applyPlacement(calculatedOffset, placement)\x0a\x0a      var complete = function () {\x0a        var prevHoverState = that.hoverState\x0a        that.$element.trigger(\x27shown.bs.\x27 + that.type)\x0a        that.hoverState = null\x0a\x0a        if (prevHoverState == \x27out\x27) that.leave(that)\x0a      }\x0a\x0a      $.support.transition && this.$tip.hasClass(\x27fade\x27) ?\x0a        $tip\x0a          .one(\x27bsTransitionEnd\x27, complete)\x0a          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\x0a        complete()\x0a    }\x0a  }\x0a\x0a  Tooltip.prototype.applyPlacement = function (offset, placement) {\x0a    var $tip   = this.tip()\x0a    var width  = $tip[0].offsetWidth\x0a    var height = $tip[0].offsetHeight\x0a\x0a    // manually read margins because getBoundingClientRect includes difference\x0a    var marginTop = parseInt($tip.css(\x27margin-top\x27), 10)\x0a    var marginLeft = parseInt($tip.css(\x27margin-left\x27), 10)\x0a\x0a    // we must check for NaN for ie 8/9\x0a    if (isNaN(marginTop))  marginTop  = 0\x0a    if (isNaN(marginLeft)) marginLeft = 0\x0a\x0a    offset.top  += marginTop\x0a    offset.left += marginLeft\x0a\x0a    // $.fn.offset doesn\x27t round pixel values\x0a    // so we use setOffset directly with our own function B-0\x0a    $.offset.setOffset($tip[0], $.extend({\x0a      using: function (props) {\x0a        $tip.css({\x0a          top: Math.round(props.top),\x0a          left: Math.round(props.left)\x0a        })\x0a      }\x0a    }, offset), 0)\x0a\x0a    $tip.addClass(\x27in\x27)\x0a\x0a    // check to see if placing tip in new offset caused the tip to resize itself\x0a    var actualWidth  = $tip[0].offsetWidth\x0a    var actualHeight = $tip[0].offsetHeight\x0a\x0a    if (placement == \x27top\x27 && actualHeight != height) {\x0a      offset.top = offset.top + height - actualHeight\x0a    }\x0a\x0a    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\x0a\x0a    if (delta.left) offset.left += delta.left\x0a    else offset.top += delta.top\x0a\x0a    var isVertical          = /top|bottom/.test(placement)\x0a    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\x0a    var arrowOffsetPosition = isVertical ? \x27offsetWidth\x27 : \x27offsetHeight\x27\x0a\x0a    $tip.offset(offset)\x0a    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\x0a  }\x0a\x0a  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\x0a    this.arrow()\x0a      .css(isVertical ? \x27left\x27 : \x27top\x27, 50 * (1 - delta / dimension) + \x27%\x27)\x0a      .css(isVertical ? \x27top\x27 : \x27left\x27, \x27\x27)\x0a  }\x0a\x0a  Tooltip.prototype.setContent = function () {\x0a    var $tip  = this.tip()\x0a    var title = this.getTitle()\x0a\x0a    $tip.find(\x27.tooltip-inner\x27)[this.options.html ? \x27html\x27 : \x27text\x27](title)\x0a    $tip.removeClass(\x27fade in top bottom left right\x27)\x0a  }\x0a\x0a  Tooltip.prototype.hide = function (callback) {\x0a    var that = this\x0a    var $tip = $(this.$tip)\x0a    var e    = $.Event(\x27hide.bs.\x27 + this.type)\x0a\x0a    function complete() {\x0a      if (that.hoverState != \x27in\x27) $tip.detach()\x0a      that.$element\x0a        .removeAttr(\x27aria-describedby\x27)\x0a        .trigger(\x27hidden.bs.\x27 + that.type)\x0a      callback && callback()\x0a    }\x0a\x0a    this.$element.trigger(e)\x0a\x0a    if (e.isDefaultPrevented()) return\x0a\x0a    $tip.removeClass(\x27in\x27)\x0a\x0a    $.support.transition && $tip.hasClass(\x27fade\x27) ?\x0a      $tip\x0a        .one(\x27bsTransitionEnd\x27, complete)\x0a        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\x0a      complete()\x0a\x0a    this.hoverState = null\x0a\x0a    return this\x0a  }\x0a\x0a  Tooltip.prototype.fixTitle = function () {\x0a    var $e = this.$element\x0a    if ($e.attr(\x27title\x27) || typeof $e.attr(\x27data-original-title\x27) != \x27string\x27) {\x0a      $e.attr(\x27data-original-title\x27, $e.attr(\x27title\x27) || \x27\x27).attr(\x27title\x27, \x27\x27)\x0a    }\x0a  }\x0a\x0a  Tooltip.prototype.hasContent = function () {\x0a    return this.getTitle()\x0a  }\x0a\x0a  Tooltip.prototype.getPosition = function ($element) {\x0a    $element   = $element || this.$element\x0a\x0a    var el     = $element[0]\x0a    var isBody = el.tagName == \x27BODY\x27\x0a\x0a    var elRect    = el.getBoundingClientRect()\x0a    if (elRect.width == null) {\x0a      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\x0a      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\x0a    }\x0a    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()\x0a    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\x0a    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\x0a\x0a    return $.extend({}, elRect, scroll, outerDims, elOffset)\x0a  }\x0a\x0a  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\x0a    return placement == \x27bottom\x27 ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\x0a           placement == \x27top\x27    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\x0a           placement == \x27left\x27   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\x0a        /* placement == \x27right\x27 */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\x0a\x0a  }\x0a\x0a  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\x0a    var delta = { top: 0, left: 0 }\x0a    if (!this.$viewport) return delta\x0a\x0a    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\x0a    var viewportDimensions = this.getPosition(this.$viewport)\x0a\x0a    if (/right|left/.test(placement)) {\x0a      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\x0a      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\x0a      if (topEdgeOffset \x3c viewportDimensions.top) { // top overflow\x0a        delta.top = viewportDimensions.top - topEdgeOffset\x0a      } else if (bottomEdgeOffset \x3e viewportDimensions.top + viewportDimensions.height) { // bottom overflow\x0a        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\x0a      }\x0a    } else {\x0a      var leftEdgeOffset  = pos.left - viewportPadding\x0a      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\x0a      if (leftEdgeOffset \x3c viewportDimensions.left) { // left overflow\x0a        delta.left = viewportDimensions.left - leftEdgeOffset\x0a      } else if (rightEdgeOffset \x3e viewportDimensions.right) { // right overflow\x0a        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\x0a      }\x0a    }\x0a\x0a    return delta\x0a  }\x0a\x0a  Tooltip.prototype.getTitle = function () {\x0a    var title\x0a    var $e = this.$element\x0a    var o  = this.options\x0a\x0a    title = $e.attr(\x27data-original-title\x27)\x0a      || (typeof o.title == \x27function\x27 ? o.title.call($e[0]) :  o.title)\x0a\x0a    return title\x0a  }\x0a\x0a  Tooltip.prototype.getUID = function (prefix) {\x0a    do prefix += ~~(Math.random() * 1000000)\x0a    while (document.getElementById(prefix))\x0a    return prefix\x0a  }\x0a\x0a  Tooltip.prototype.tip = function () {\x0a    if (!this.$tip) {\x0a      this.$tip = $(this.options.template)\x0a      if (this.$tip.length != 1) {\x0a        throw new Error(this.type + \x27 `template` option must consist of exactly 1 top-level element!\x27)\x0a      }\x0a    }\x0a    return this.$tip\x0a  }\x0a\x0a  Tooltip.prototype.arrow = function () {\x0a    return (this.$arrow = this.$arrow || this.tip().find(\x27.tooltip-arrow\x27))\x0a  }\x0a\x0a  Tooltip.prototype.enable = function () {\x0a    this.enabled = true\x0a  }\x0a\x0a  Tooltip.prototype.disable = function () {\x0a    this.enabled = false\x0a  }\x0a\x0a  Tooltip.prototype.toggleEnabled = function () {\x0a    this.enabled = !this.enabled\x0a  }\x0a\x0a  Tooltip.prototype.toggle = function (e) {\x0a    var self = this\x0a    if (e) {\x0a      self = $(e.currentTarget).data(\x27bs.\x27 + this.type)\x0a      if (!self) {\x0a        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\x0a        $(e.currentTarget).data(\x27bs.\x27 + this.type, self)\x0a      }\x0a    }\x0a\x0a    if (e) {\x0a      self.inState.click = !self.inState.click\x0a      if (self.isInStateTrue()) self.enter(self)\x0a      else self.leave(self)\x0a    } else {\x0a      self.tip().hasClass(\x27in\x27) ? self.leave(self) : self.enter(self)\x0a    }\x0a  }\x0a\x0a  Tooltip.prototype.destroy = function () {\x0a    var that = this\x0a    clearTimeout(this.timeout)\x0a    this.hide(function () {\x0a      that.$element.off(\x27.\x27 + that.type).removeData(\x27bs.\x27 + that.type)\x0a      if (that.$tip) {\x0a        that.$tip.detach()\x0a      }\x0a      that.$tip = null\x0a      that.$arrow = null\x0a      that.$viewport = null\x0a    })\x0a  }\x0a\x0a\x0a  // TOOLTIP PLUGIN DEFINITION\x0a  // =========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.tooltip\x27)\x0a      var options = typeof option == \x27object\x27 && option\x0a\x0a      if (!data && /destroy|hide/.test(option)) return\x0a      if (!data) $this.data(\x27bs.tooltip\x27, (data = new Tooltip(this, options)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.tooltip\x0a\x0a  $.fn.tooltip             = Plugin\x0a  $.fn.tooltip.Constructor = Tooltip\x0a\x0a\x0a  // TOOLTIP NO CONFLICT\x0a  // ===================\x0a\x0a  $.fn.tooltip.noConflict = function () {\x0a    $.fn.tooltip = old\x0a    return this\x0a  }\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: popover.js v3.3.5\x0a * http://getbootstrap.com/javascript/#popovers\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // POPOVER PUBLIC CLASS DEFINITION\x0a  // ===============================\x0a\x0a  var Popover = function (element, options) {\x0a    this.init(\x27popover\x27, element, options)\x0a  }\x0a\x0a  if (!$.fn.tooltip) throw new Error(\x27Popover requires tooltip.js\x27)\x0a\x0a  Popover.VERSION  = \x273.3.5\x27\x0a\x0a  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\x0a    placement: \x27right\x27,\x0a    trigger: \x27click\x27,\x0a    content: \x27\x27,\x0a    template: \x27\x3cdiv class=\x22popover\x22 role=\x22tooltip\x22\x3e\x3cdiv class=\x22arrow\x22\x3e\x3c/div\x3e\x3ch3 class=\x22popover-title\x22\x3e\x3c/h3\x3e\x3cdiv class=\x22popover-content\x22\x3e\x3c/div\x3e\x3c/div\x3e\x27\x0a  })\x0a\x0a\x0a  // NOTE: POPOVER EXTENDS tooltip.js\x0a  // ================================\x0a\x0a  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\x0a\x0a  Popover.prototype.constructor = Popover\x0a\x0a  Popover.prototype.getDefaults = function () {\x0a    return Popover.DEFAULTS\x0a  }\x0a\x0a  Popover.prototype.setContent = function () {\x0a    var $tip    = this.tip()\x0a    var title   = this.getTitle()\x0a    var content = this.getContent()\x0a\x0a    $tip.find(\x27.popover-title\x27)[this.options.html ? \x27html\x27 : \x27text\x27](title)\x0a    $tip.find(\x27.popover-content\x27).children().detach().end()[ // we use append for html objects to maintain js events\x0a      this.options.html ? (typeof content == \x27string\x27 ? \x27html\x27 : \x27append\x27) : \x27text\x27\x0a    ](content)\x0a\x0a    $tip.removeClass(\x27fade top bottom left right in\x27)\x0a\x0a    // IE8 doesn\x27t accept hiding via the `:empty` pseudo selector, we have to do\x0a    // this manually by checking the contents.\x0a    if (!$tip.find(\x27.popover-title\x27).html()) $tip.find(\x27.popover-title\x27).hide()\x0a  }\x0a\x0a  Popover.prototype.hasContent = function () {\x0a    return this.getTitle() || this.getContent()\x0a  }\x0a\x0a  Popover.prototype.getContent = function () {\x0a    var $e = this.$element\x0a    var o  = this.options\x0a\x0a    return $e.attr(\x27data-content\x27)\x0a      || (typeof o.content == \x27function\x27 ?\x0a            o.content.call($e[0]) :\x0a            o.content)\x0a  }\x0a\x0a  Popover.prototype.arrow = function () {\x0a    return (this.$arrow = this.$arrow || this.tip().find(\x27.arrow\x27))\x0a  }\x0a\x0a\x0a  // POPOVER PLUGIN DEFINITION\x0a  // =========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.popover\x27)\x0a      var options = typeof option == \x27object\x27 && option\x0a\x0a      if (!data && /destroy|hide/.test(option)) return\x0a      if (!data) $this.data(\x27bs.popover\x27, (data = new Popover(this, options)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.popover\x0a\x0a  $.fn.popover             = Plugin\x0a  $.fn.popover.Constructor = Popover\x0a\x0a\x0a  // POPOVER NO CONFLICT\x0a  // ===================\x0a\x0a  $.fn.popover.noConflict = function () {\x0a    $.fn.popover = old\x0a    return this\x0a  }\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: scrollspy.js v3.3.5\x0a * http://getbootstrap.com/javascript/#scrollspy\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // SCROLLSPY CLASS DEFINITION\x0a  // ==========================\x0a\x0a  function ScrollSpy(element, options) {\x0a    this.$body          = $(document.body)\x0a    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\x0a    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\x0a    this.selector       = (this.options.target || \x27\x27) + \x27 .nav li \x3e a\x27\x0a    this.offsets        = []\x0a    this.targets        = []\x0a    this.activeTarget   = null\x0a    this.scrollHeight   = 0\x0a\x0a    this.$scrollElement.on(\x27scroll.bs.scrollspy\x27, $.proxy(this.process, this))\x0a    this.refresh()\x0a    this.process()\x0a  }\x0a\x0a  ScrollSpy.VERSION  = \x273.3.5\x27\x0a\x0a  ScrollSpy.DEFAULTS = {\x0a    offset: 10\x0a  }\x0a\x0a  ScrollSpy.prototype.getScrollHeight = function () {\x0a    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\x0a  }\x0a\x0a  ScrollSpy.prototype.refresh = function () {\x0a    var that          = this\x0a    var offsetMethod  = \x27offset\x27\x0a    var offsetBase    = 0\x0a\x0a    this.offsets      = []\x0a    this.targets      = []\x0a    this.scrollHeight = this.getScrollHeight()\x0a\x0a    if (!$.isWindow(this.$scrollElement[0])) {\x0a      offsetMethod = \x27position\x27\x0a      offsetBase   = this.$scrollElement.scrollTop()\x0a    }\x0a\x0a    this.$body\x0a      .find(this.selector)\x0a      .map(function () {\x0a        var $el   = $(this)\x0a        var href  = $el.data(\x27target\x27) || $el.attr(\x27href\x27)\x0a        var $href = /^#./.test(href) && $(href)\x0a\x0a        return ($href\x0a          && $href.length\x0a          && $href.is(\x27:visible\x27)\x0a          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\x0a      })\x0a      .sort(function (a, b) { return a[0] - b[0] })\x0a      .each(function () {\x0a        that.offsets.push(this[0])\x0a        that.targets.push(this[1])\x0a      })\x0a  }\x0a\x0a  ScrollSpy.prototype.process = function () {\x0a    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\x0a    var scrollHeight = this.getScrollHeight()\x0a    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\x0a    var offsets      = this.offsets\x0a    var targets      = this.targets\x0a    var activeTarget = this.activeTarget\x0a    var i\x0a\x0a    if (this.scrollHeight != scrollHeight) {\x0a      this.refresh()\x0a    }\x0a\x0a    if (scrollTop \x3e= maxScroll) {\x0a      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\x0a    }\x0a\x0a    if (activeTarget && scrollTop \x3c offsets[0]) {\x0a      this.activeTarget = null\x0a      return this.clear()\x0a    }\x0a\x0a    for (i = offsets.length; i--;) {\x0a      activeTarget != targets[i]\x0a        && scrollTop \x3e= offsets[i]\x0a        && (offsets[i + 1] === undefined || scrollTop \x3c offsets[i + 1])\x0a        && this.activate(targets[i])\x0a    }\x0a  }\x0a\x0a  ScrollSpy.prototype.activate = function (target) {\x0a    this.activeTarget = target\x0a\x0a    this.clear()\x0a\x0a    var selector = this.selector +\x0a      \x27[data-target=\x22\x27 + target + \x27\x22],\x27 +\x0a      this.selector + \x27[href=\x22\x27 + target + \x27\x22]\x27\x0a\x0a    var active = $(selector)\x0a      .parents(\x27li\x27)\x0a      .addClass(\x27active\x27)\x0a\x0a    if (active.parent(\x27.dropdown-menu\x27).length) {\x0a      active = active\x0a        .closest(\x27li.dropdown\x27)\x0a        .addClass(\x27active\x27)\x0a    }\x0a\x0a    active.trigger(\x27activate.bs.scrollspy\x27)\x0a  }\x0a\x0a  ScrollSpy.prototype.clear = function () {\x0a    $(this.selector)\x0a      .parentsUntil(this.options.target, \x27.active\x27)\x0a      .removeClass(\x27active\x27)\x0a  }\x0a\x0a\x0a  // SCROLLSPY PLUGIN DEFINITION\x0a  // ===========================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.scrollspy\x27)\x0a      var options = typeof option == \x27object\x27 && option\x0a\x0a      if (!data) $this.data(\x27bs.scrollspy\x27, (data = new ScrollSpy(this, options)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.scrollspy\x0a\x0a  $.fn.scrollspy             = Plugin\x0a  $.fn.scrollspy.Constructor = ScrollSpy\x0a\x0a\x0a  // SCROLLSPY NO CONFLICT\x0a  // =====================\x0a\x0a  $.fn.scrollspy.noConflict = function () {\x0a    $.fn.scrollspy = old\x0a    return this\x0a  }\x0a\x0a\x0a  // SCROLLSPY DATA-API\x0a  // ==================\x0a\x0a  $(window).on(\x27load.bs.scrollspy.data-api\x27, function () {\x0a    $(\x27[data-spy=\x22scroll\x22]\x27).each(function () {\x0a      var $spy = $(this)\x0a      Plugin.call($spy, $spy.data())\x0a    })\x0a  })\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: tab.js v3.3.5\x0a * http://getbootstrap.com/javascript/#tabs\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // TAB CLASS DEFINITION\x0a  // ====================\x0a\x0a  var Tab = function (element) {\x0a    // jscs:disable requireDollarBeforejQueryAssignment\x0a    this.element = $(element)\x0a    // jscs:enable requireDollarBeforejQueryAssignment\x0a  }\x0a\x0a  Tab.VERSION = \x273.3.5\x27\x0a\x0a  Tab.TRANSITION_DURATION = 150\x0a\x0a  Tab.prototype.show = function () {\x0a    var $this    = this.element\x0a    var $ul      = $this.closest(\x27ul:not(.dropdown-menu)\x27)\x0a    var selector = $this.data(\x27target\x27)\x0a\x0a    if (!selector) {\x0a      selector = $this.attr(\x27href\x27)\x0a      selector = selector && selector.replace(/.*(?=#[^\x5cs]*$)/, \x27\x27) // strip for ie7\x0a    }\x0a\x0a    if ($this.parent(\x27li\x27).hasClass(\x27active\x27)) return\x0a\x0a    var $previous = $ul.find(\x27.active:last a\x27)\x0a    var hideEvent = $.Event(\x27hide.bs.tab\x27, {\x0a      relatedTarget: $this[0]\x0a    })\x0a    var showEvent = $.Event(\x27show.bs.tab\x27, {\x0a      relatedTarget: $previous[0]\x0a    })\x0a\x0a    $previous.trigger(hideEvent)\x0a    $this.trigger(showEvent)\x0a\x0a    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\x0a\x0a    var $target = $(selector)\x0a\x0a    this.activate($this.closest(\x27li\x27), $ul)\x0a    this.activate($target, $target.parent(), function () {\x0a      $previous.trigger({\x0a        type: \x27hidden.bs.tab\x27,\x0a        relatedTarget: $this[0]\x0a      })\x0a      $this.trigger({\x0a        type: \x27shown.bs.tab\x27,\x0a        relatedTarget: $previous[0]\x0a      })\x0a    })\x0a  }\x0a\x0a  Tab.prototype.activate = function (element, container, callback) {\x0a    var $active    = container.find(\x27\x3e .active\x27)\x0a    var transition = callback\x0a      && $.support.transition\x0a      && ($active.length && $active.hasClass(\x27fade\x27) || !!container.find(\x27\x3e .fade\x27).length)\x0a\x0a    function next() {\x0a      $active\x0a        .removeClass(\x27active\x27)\x0a        .find(\x27\x3e .dropdown-menu \x3e .active\x27)\x0a          .removeClass(\x27active\x27)\x0a        .end()\x0a        .find(\x27[data-toggle=\x22tab\x22]\x27)\x0a          .attr(\x27aria-expanded\x27, false)\x0a\x0a      element\x0a        .addClass(\x27active\x27)\x0a        .find(\x27[data-toggle=\x22tab\x22]\x27)\x0a          .attr(\x27aria-expanded\x27, true)\x0a\x0a      if (transition) {\x0a        element[0].offsetWidth // reflow for transition\x0a        element.addClass(\x27in\x27)\x0a      } else {\x0a        element.removeClass(\x27fade\x27)\x0a      }\x0a\x0a      if (element.parent(\x27.dropdown-menu\x27).length) {\x0a        element\x0a          .closest(\x27li.dropdown\x27)\x0a            .addClass(\x27active\x27)\x0a          .end()\x0a          .find(\x27[data-toggle=\x22tab\x22]\x27)\x0a            .attr(\x27aria-expanded\x27, true)\x0a      }\x0a\x0a      callback && callback()\x0a    }\x0a\x0a    $active.length && transition ?\x0a      $active\x0a        .one(\x27bsTransitionEnd\x27, next)\x0a        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\x0a      next()\x0a\x0a    $active.removeClass(\x27in\x27)\x0a  }\x0a\x0a\x0a  // TAB PLUGIN DEFINITION\x0a  // =====================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this = $(this)\x0a      var data  = $this.data(\x27bs.tab\x27)\x0a\x0a      if (!data) $this.data(\x27bs.tab\x27, (data = new Tab(this)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.tab\x0a\x0a  $.fn.tab             = Plugin\x0a  $.fn.tab.Constructor = Tab\x0a\x0a\x0a  // TAB NO CONFLICT\x0a  // ===============\x0a\x0a  $.fn.tab.noConflict = function () {\x0a    $.fn.tab = old\x0a    return this\x0a  }\x0a\x0a\x0a  // TAB DATA-API\x0a  // ============\x0a\x0a  var clickHandler = function (e) {\x0a    e.preventDefault()\x0a    Plugin.call($(this), \x27show\x27)\x0a  }\x0a\x0a  $(document)\x0a    .on(\x27click.bs.tab.data-api\x27, \x27[data-toggle=\x22tab\x22]\x27, clickHandler)\x0a    .on(\x27click.bs.tab.data-api\x27, \x27[data-toggle=\x22pill\x22]\x27, clickHandler)\x0a\x0a}(jQuery);\x0a\x0a/* ========================================================================\x0a * Bootstrap: affix.js v3.3.5\x0a * http://getbootstrap.com/javascript/#affix\x0a * ========================================================================\x0a * Copyright 2011-2015 Twitter, Inc.\x0a * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\x0a * ======================================================================== */\x0a\x0a\x0a+function ($) {\x0a  \x27use strict\x27;\x0a\x0a  // AFFIX CLASS DEFINITION\x0a  // ======================\x0a\x0a  var Affix = function (element, options) {\x0a    this.options = $.extend({}, Affix.DEFAULTS, options)\x0a\x0a    this.$target = $(this.options.target)\x0a      .on(\x27scroll.bs.affix.data-api\x27, $.proxy(this.checkPosition, this))\x0a      .on(\x27click.bs.affix.data-api\x27,  $.proxy(this.checkPositionWithEventLoop, this))\x0a\x0a    this.$element     = $(element)\x0a    this.affixed      = null\x0a    this.unpin        = null\x0a    this.pinnedOffset = null\x0a\x0a    this.checkPosition()\x0a  }\x0a\x0a  Affix.VERSION  = \x273.3.5\x27\x0a\x0a  Affix.RESET    = \x27affix affix-top affix-bottom\x27\x0a\x0a  Affix.DEFAULTS = {\x0a    offset: 0,\x0a    target: window\x0a  }\x0a\x0a  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\x0a    var scrollTop    = this.$target.scrollTop()\x0a    var position     = this.$element.offset()\x0a    var targetHeight = this.$target.height()\x0a\x0a    if (offsetTop != null && this.affixed == \x27top\x27) return scrollTop \x3c offsetTop ? \x27top\x27 : false\x0a\x0a    if (this.affixed == \x27bottom\x27) {\x0a      if (offsetTop != null) return (scrollTop + this.unpin \x3c= position.top) ? false : \x27bottom\x27\x0a      return (scrollTop + targetHeight \x3c= scrollHeight - offsetBottom) ? false : \x27bottom\x27\x0a    }\x0a\x0a    var initializing   = this.affixed == null\x0a    var colliderTop    = initializing ? scrollTop : position.top\x0a    var colliderHeight = initializing ? targetHeight : height\x0a\x0a    if (offsetTop != null && scrollTop \x3c= offsetTop) return \x27top\x27\x0a    if (offsetBottom != null && (colliderTop + colliderHeight \x3e= scrollHeight - offsetBottom)) return \x27bottom\x27\x0a\x0a    return false\x0a  }\x0a\x0a  Affix.prototype.getPinnedOffset = function () {\x0a    if (this.pinnedOffset) return this.pinnedOffset\x0a    this.$element.removeClass(Affix.RESET).addClass(\x27affix\x27)\x0a    var scrollTop = this.$target.scrollTop()\x0a    var position  = this.$element.offset()\x0a    return (this.pinnedOffset = position.top - scrollTop)\x0a  }\x0a\x0a  Affix.prototype.checkPositionWithEventLoop = function () {\x0a    setTimeout($.proxy(this.checkPosition, this), 1)\x0a  }\x0a\x0a  Affix.prototype.checkPosition = function () {\x0a    if (!this.$element.is(\x27:visible\x27)) return\x0a\x0a    var height       = this.$element.height()\x0a    var offset       = this.options.offset\x0a    var offsetTop    = offset.top\x0a    var offsetBottom = offset.bottom\x0a    var scrollHeight = Math.max($(document).height(), $(document.body).height())\x0a\x0a    if (typeof offset != \x27object\x27)         offsetBottom = offsetTop = offset\x0a    if (typeof offsetTop == \x27function\x27)    offsetTop    = offset.top(this.$element)\x0a    if (typeof offsetBottom == \x27function\x27) offsetBottom = offset.bottom(this.$element)\x0a\x0a    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\x0a\x0a    if (this.affixed != affix) {\x0a      if (this.unpin != null) this.$element.css(\x27top\x27, \x27\x27)\x0a\x0a      var affixType = \x27affix\x27 + (affix ? \x27-\x27 + affix : \x27\x27)\x0a      var e         = $.Event(affixType + \x27.bs.affix\x27)\x0a\x0a      this.$element.trigger(e)\x0a\x0a      if (e.isDefaultPrevented()) return\x0a\x0a      this.affixed = affix\x0a      this.unpin = affix == \x27bottom\x27 ? this.getPinnedOffset() : null\x0a\x0a      this.$element\x0a        .removeClass(Affix.RESET)\x0a        .addClass(affixType)\x0a        .trigger(affixType.replace(\x27affix\x27, \x27affixed\x27) + \x27.bs.affix\x27)\x0a    }\x0a\x0a    if (affix == \x27bottom\x27) {\x0a      this.$element.offset({\x0a        top: scrollHeight - height - offsetBottom\x0a      })\x0a    }\x0a  }\x0a\x0a\x0a  // AFFIX PLUGIN DEFINITION\x0a  // =======================\x0a\x0a  function Plugin(option) {\x0a    return this.each(function () {\x0a      var $this   = $(this)\x0a      var data    = $this.data(\x27bs.affix\x27)\x0a      var options = typeof option == \x27object\x27 && option\x0a\x0a      if (!data) $this.data(\x27bs.affix\x27, (data = new Affix(this, options)))\x0a      if (typeof option == \x27string\x27) data[option]()\x0a    })\x0a  }\x0a\x0a  var old = $.fn.affix\x0a\x0a  $.fn.affix             = Plugin\x0a  $.fn.affix.Constructor = Affix\x0a\x0a\x0a  // AFFIX NO CONFLICT\x0a  // =================\x0a\x0a  $.fn.affix.noConflict = function () {\x0a    $.fn.affix = old\x0a    return this\x0a  }\x0a\x0a\x0a  // AFFIX DATA-API\x0a  // ==============\x0a\x0a  $(window).on(\x27load\x27, function () {\x0a    $(\x27[data-spy=\x22affix\x22]\x27).each(function () {\x0a      var $spy = $(this)\x0a      var data = $spy.data()\x0a\x0a      data.offset = data.offset || {}\x0a\x0a      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\x0a      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\x0a\x0a      Plugin.call($spy, data)\x0a    })\x0a  })\x0a\x0a}(jQuery);\x0a\xc8\xb3~\x9b l\x87\xbd\x01@'}